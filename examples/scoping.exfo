extern "C" func printf(char_ptr, ...): void;

func to_string(a: bool): char_ptr {
    if a return "true";
    return "false";
}

func main(): int {
    printf("(scoping: this is a code example, please open scoping.exfo to see what it is about)\n");

    // Variables are declared / shadowed (see below) using := operator.
    a := 1;
    printf("before shadowing: a = %d\n", a);
    // Shadowing. `a` now points to another variable on the stack.
    // Note that you can also use the previous value in the initializer as it is still reachable.
    a := a + 1;
    printf("after shadowing:  a = %d (a is still integer)\n", a); // prints "2"
    
    // Changing type via shadowing. Exfo is statically typed language, but a single name can point 
    // to couple if different "objects" in memory at different code locations (even in the same scope)
    // After variable shadowing, previous value unreachable.
    a := false; 
    printf("after shadowing:  a = %s (a is boolean now)\n", to_string(a));  // prints "false"
    
    a := 2; 
    a = a + 1; // Mutation. Update add "1" to the memory pointed by "a" 
    printf("after mutation & shadowing: a = %d\n", a);

    // Scopes.
    b := 10;
    c := 15;
    printf("Outer scope: b = %d, c = %d\n", b, c);
    {
        // After being declared in inner scope,
        // the "b" variable is now bounded to the different value (just as previously with shadowing),
        // but this is only until the end of this scope.
        b := b + 1;
        // scopes also can mutate variables from outer scopes like this:
        c = c * c; // This statement affects outer scope (squares "c")
        printf("  Inner scope: b = %d, c = %d\n", b, c);
    }
    printf("Outer scope: b = %d, c = %d (b left unchanged) \n", b, c);
    
    return 0; 
} 
