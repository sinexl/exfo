extern "C" func memcmp(int*, int*, int): int;
extern "C" func printf(char_ptr, ...): void;

func get_string(a: bool): char_ptr {
    if a  return "true";
    else  return "false";
}

func not(a: bool): bool {
    if a return false;
    return true;
}

func inverse(le: bool*, ge: bool*, leq: bool*, geq: bool*): void {
    s_le  := *le;
    s_ge  := *ge;
    s_leq := *leq;
    s_geq := *geq;


    *le = not(s_leq); *ge = not(s_geq);
    *leq = not(s_le); *geq = not(s_ge);
}

func main(): int {
    True := true;
    False := false;
    size := 8;

    i := -1; while i <= 1 {
        j := -1; while j <= 1 {
            le  := i < j;
            ge  := i > j;
            leq := i <= j;
            geq := i >= j;

            // Expected
            cmp := memcmp(&i, &j, size);
            e_eq  := cmp == 0;
            e_neq := cmp != 0;

            // TODO: this is technically dumb to verify how ordering operators work using themselves.
            //   Introduce  better way to do this.
            //   Expected orders.
            e_le  := cmp < 0;
            e_ge  := cmp > 0;
            e_leq := cmp < 0 || e_eq;
            e_geq := cmp > 0 || e_eq;

            // Memcmp doesnt take into account the sign.
            if i < 0 {
                inverse(&e_le, &e_ge, &e_leq, &e_geq);
            }
            //if j < 0 {
            //    e_le = not(e_leq); e_ge = not(e_geq);
            //    e_leq = not(e_le); e_geq = not(e_ge);
            //}
            printf("< --- (i, j) = (%d, %d) --- >%c", i, j, 10);
            printf("%3d <  %d: %5s (expected: %5s)%c", i, j, get_string(le),  get_string(e_le),  10);
            printf("%3d >  %d: %5s (expected: %5s)%c", i, j, get_string(ge),  get_string(e_ge),  10);
            printf("%3d <= %d: %5s (expected: %5s)%c", i, j, get_string(leq), get_string(e_leq), 10);
            printf("%3d >= %d: %5s (expected: %5s)%c", i, j, get_string(geq), get_string(e_geq), 10);
            j = j + 1;
        }
        i = i + 1;
    }



    return 0;
}
