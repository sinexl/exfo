extern "C" func memcmp(int*, int*, int): int;
extern "C" func printf(char_ptr, ...): void;

func get_string(a: bool): char_ptr {
    if a == false return "false";
    else if a == true return "true";
}

func main(): int {
    True := true;
    False := false;
    size := 8;

    i := 0; while i < 3 {
        j := 0; while j < 3 {
            le  := i < j;
            ge  := i > j;
            leq := i <= j;
            geq := i >= j;

            // Expected
            cmp := memcmp(&i, &j, size);
            e_eq  := cmp == 0;
            e_neq := cmp != 0;

            // TODO: this is technically dumb to verify how ordering operators work using themselves.
            //   Introduce  better way to do this.
            //   Expected orders.
            e_le  := cmp < 0;
            e_ge  := cmp > 0;
            e_leq := cmp < 0 || e_eq;
            e_geq := cmp > 0 || e_eq;
            printf("< --- (i, j) = (%d%d) --- >%c", i, j, 10);
            printf("%d <  %d: %5s (expected: %5s)%c", i, j, get_string(le),  get_string(e_le),  10);
            printf("%d >  %d: %5s (expected: %5s)%c", i, j, get_string(ge),  get_string(e_ge),  10);
            printf("%d <= %d: %5s (expected: %5s)%c", i, j, get_string(leq), get_string(e_leq), 10);
            printf("%d >= %d: %5s (expected: %5s)%c", i, j, get_string(geq), get_string(e_geq), 10);
            j = j + 1;
        }
        i = i + 1;
    }



    return 0;
}
